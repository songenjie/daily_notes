MergeTree: 一本书

Primary.idx: 一级索引好比这本书的一级章节目录

.bin ：整个书的问题

.mrk ：数据标记，为一级章节目录和具体的文字之间建立关联



- .mrk ：记录，目的 查询某段文字所在页码和第几行 说白就是一级索引和文件的关联（桥梁）

1. 一级章节对应的页码位置
2. 一段文字在某一页中的起始位置。 



![数据读取关系图](https://github.com/songenjie/daily_notes/blob/master/source/clickhouse_存储关系图.jpg) 

- 特征

1. 首先第多少行就是第多少个字节，说明当前列 就是一个Uint8 (1B*8192=8192B,64Kb=65536B=8*8192B)
2. Index_granularity 8192



| .mrk           | .mrk                                                         | .mrk                 | 当前行所在偏移大小 |            | .binhead   | .binhead   |
| -------------- | ------------------------------------------------------------ | -------------------- | ------------------ | ---------- | ---------- | ---------- |
| 未压缩文件编号 | 压缩块偏移量                                                 | 未/解压缩块偏移量 行 | 偏移大小           | 压缩块编号 | 压缩块大小 | 未压缩大小 |
| 0              | 0                                                            | 0                    | 0                  | 0          |            |            |
| 1              | 0                                                            | 8192                 | 8192               | 0          |            |            |
| 2              | 0                                                            | 16384                | 16384              | 0          |            |            |
| 3              | 0                                                            | 24576                | 24576              | 0          |            |            |
| 4              | 0                                                            | 32768                | 32768              | 0          |            |            |
| 5              | 0                                                            | 40960                | 40960              | 0          |            |            |
| 6              | 0                                                            | 49152                | 49152              | 0          |            |            |
| 7              | 0                                                            | 57344                | 57344              | 0          | 12000      | 65535      |
| 8              | 12016                                                        | 65536/0              | 65536              | 1          | 14661      | 65535      |
| 9              | 12016=8(前压缩块头)+12000(前压缩块大小)+8(当前压缩块的头大小) | 8192                 | 65536+8192         | 1          |            |            |
|                | 12016                                                        | ...                  |                    | 1          |            |            |
|                | ...                                                          |                      |                    |            |            |            |
|                | 1402429                                                      |                      |                    |            |            |            |



一个压缩块，是最小解压单元 

12016+8192 找编号为1的压缩块的地8192行的数据

整个字段比较凑巧  



- 特征

1. 首先第多少行就是第多少个字节，说明当前列 就是一个Uint16 (2B *8192=16384B,64Kb=65536B= 4* * 16384B)
2. Index_granularity 8192
3. 



| .mrk           | .mrk                                                         | .mrk                 | 当前行所在字节大小 |            | .binhead   | .binhead   |
| -------------- | ------------------------------------------------------------ | -------------------- | ------------------ | ---------- | ---------- | ---------- |
| 未压缩文件编号 | 压缩块偏移量                                                 | 未/解压缩块偏移量 行 | 偏移大小           | 压缩块编号 | 压缩块大小 | 未压缩大小 |
| 0              | 0                                                            | 0                    | 0                  | 0          |            |            |
| 1              | 0                                                            | 8192                 | 16384              | 0          |            |            |
| 2              | 0                                                            | 16384                | 32768              | 0          |            |            |
| 3              | 0                                                            | 24576                | 49152              | 0          | 12000      | 65525      |
| 4              | 12016=8(前压缩块头)+12000(前压缩块大小)+8(当前压缩块的头大小) | 32768                | 65536              | 1          | 14661      | 65535      |
| 5              | 12016                                                        | 40960                | 63336+16384        | 1          |            |            |
| 6              | 12016                                                        | 49152                |                    | 1          |            |            |
| 7              | 12016                                                        | 57344                |                    | 1          | 14661      | 65535      |
| 8              | *=8+12000+8+14661+8                                          | 65536/0              |                    | 2          | *          | 65535      |
| 9              | *=8+12000+8+14661+8                                          | 8192                 |                    | 2          |            |            |



分区 partition + 索引 primary key + 标记 ark + 压缩 bin,

![索引和标记的关系](/source/clickhouse_索引_标记关系.jpg)



索引和标记的对齐的，标记与压缩块根据当前字段长度的不同，会出现 多对一，和一对一，一对多的情况

上面的例子就都是多对一的情况

 

这取决于 该列 字段的大小  1bytes 8 bytes  8bytes

![多对一](/source/clickhouse_索引_压缩块_多对一.jpg)

![一对一](/source/clickhouse_索引_压缩块_一对一.jpg)

![一对多](/source/clickhouse_索引_压缩块_一对多.jpg)



