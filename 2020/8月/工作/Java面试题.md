1. ### **== 和 equals 的区别是什么？**

   **== 解读**：

   对于 基本类型 和 引用类型  == 的作用效果是**不同**的，如下所示：

   - 基本类型：比较的是值是否相同；
   - 引用类型：比较的是引用是否相同；

   **equals 解读**：

   equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了**值比较**。

2. ### **两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？**

   不对，两个对象的 hashCode()相同，equals()不一定 true。

3. ### **final 在 java 中有什么作用？**

   - final 修饰的类叫最终类，该类不能被继承。
   - final 修饰的方法不能被重写。
   - final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。

4. ### **String 属于基础的数据类型吗？JAVA中的基本数据类型有哪些？**

   String **不属于**基础类型

   基础类型有 **8 种**：byte、boolean、char、short、int、float、long、double。

5. ### **java 中操作字符串都有哪些类？它们之间有什么区别？**

   操作字符串的类有：String、StringBuffer、StringBuilder。

   String 和 StringBuffer、StringBuilder 的区别在于 **String 声明的是不可变的对象**，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 S**tringBuffer、StringBuilder 可以在原有对象的基础上进行操作**，所以在经常改变字符串内容的情况下最好不要使用 String。

   StringBuffer 和 StringBuilder 最大的**区别**在于，StringBuffer 是**线程安全**的，而 StringBuilder 是**非线程安全**的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。

6. ### **抽象类能使用 final 修饰吗？**

   不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类。

7. ### **说一下 HashMap 的实现原理？**

   HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类**不保证映射的顺序**，特别是它不保证该顺序恒久不变。 

   HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即**数组和链表**的结合体。

   当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。

   需要注意Jdk 1.8中对HashMap的实现做了优化,当**链表中**的节点数据**超过八个**之后,该链表会**转为红黑树**来提高查询效率,从原来的O(n)到O(logn)

8. ### **HashMap 和 Hashtable 有什么区别？**

   - hashTable同步的(线程安全)，而HashMap是非同步的(线程非安全)，效率上比hashTable要高。
   - hashMap允许空键值，而hashTable不允许。

9. ### **ArrayList 和 LinkedList 的区别是什么？**

   最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。

10. ### **哪些集合类是线程安全的？**

    - vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。
    - statck：堆栈类，先进后出。
    - hashtable：就比hashmap多了个线程安全。
    - enumeration：枚举，相当于迭代器。

11. ###  **守护线程是什么**

    守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。

12. ### **创建线程有哪几种方式？**

    ①. 继承Thread类创建线程类

    - 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
    - 创建Thread子类的实例，即创建了线程对象。
    - 调用线程对象的start()方法来启动该线程。

    ②. 通过Runnable接口创建线程类

    - 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
    - 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
    - 调用线程对象的start()方法来启动该线程。

    ③. 通过Callable和Future创建线程

    - 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
    - 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
    - 使用FutureTask对象作为Thread对象的target创建并启动新线程。
    - 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

13. ### **说一下 runnable 和 callable 有什么区别？**(该问题有深度)

- Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；
- Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。

14. ### **sleep() 和 wait() 有什么区别？**

    sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是**对象的锁没有被释放**，其他线程依然无法访问这个对象。

    wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时**释放对象的机锁**，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。

15. ###  **创建线程池有哪几种方式？**

    ①. newFixedThreadPool(int nThreads)

    创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。

    ②. newCachedThreadPool()

    创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。

    ③. newSingleThreadExecutor()

    这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。

    ④. newScheduledThreadPool(int corePoolSize)

    创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。

16. ### **线程池都有哪些状态？**

    线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。

17. ### **什么是死锁？怎么防止死锁？**

    死锁的四个必要条件：

    - 互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
    - 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
    - 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
    - 环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系

    这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。

18. ### **synchronized 和 Lock 有什么区别？**

    - 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
    - synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
    - synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
    - 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
    - synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；
    - Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。

19. ### **动态代理是什么？**

    当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。

    动态代理一般有 **JDK动态代理** 和 **基于CGlib的动态代理**。

20. ### **深拷贝和浅拷贝区别是什么？**

    - 浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）

    - 深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）

21. ### **Collection和Collections的区别？**

    Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。

22. ### **TreeMap和TreeSet在排序时如何比较元素？

    TreeSet要求存放的对象所属的类必须**实现Comparable接口**，该接口提供了比较元素的**compareTo()方法**，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键**必须实现Comparable接口**从而根据键对元素进行排序。

23. ### **Java中有几种类型的流？**

    字节流和字符流。字节流继承于InputStream、OutputStream；字符流继承于Reader、Writer。

    

    

    # Java虚拟机 JVM 知识：

24. ## Java内存结构？

    - Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

    - 方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

    - 程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。

    - JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

    - 本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。

25. ### 垃圾回收器

    - Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。

    - ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。

    - Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。

    - Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法

    - CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

    - G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征

26. ### 垃圾收集算法

    GC最基础的算法有三种： 标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。

    - 标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
    - 复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
    - 标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
    - 分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

27. ### 如何判断对象可以被回收？

    判断对象是否存活一般有两种方式：

- 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
- 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。



28. ### JVM的永久代中会发生垃圾回收么？

    垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。

29. ### 引用的分类

    - 强引用：GC时不会被回收

    - 软引用：描述有用但不是必须的对象，在发生内存溢出异常之前被回收

    - 弱引用：描述有用但不是必须的对象，在下一次GC时被回收

    - 虚引用（幽灵引用/幻影引用）:无法通过虚引用获得对象，用PhantomReference实现虚引用，虚引用用来在GC时返回一个通知。

30. ### 你知道哪些JVM性能调优命令

    - 设定对内存大小

      -Xmx：堆内存最大限制。

    - 设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代

      -XX:NewSize：新生代大小

      -XX:NewRatio  新生代和老生代占比

      -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比

    - 设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代

      设定垃圾回收器 年轻代用  -XX:+UseParNewGC  年老代用-XX:+UseConcMarkSweepGC

      

      